#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Latest change: Fri Mar 27 00:27:30 CET 2009
"""
fetchphotos
~~~~~~~~~~~

This script gets photos and movies from digicams,
rotates photos according to EXIF data,
adds timestamps,
lowercases filenames, and
tries to notify user on success

:copyright: (c) 2009 by Karl Voit <tools@Karl-Voit.at>
:license: GPL v2 or any later version
:bugreports: <tools@Karl-Voit.at>

"""

import re, os, time, logging, sys
from PIL import Image
from PIL.ExifTags import TAGS

from datetime import datetime
from sys import exit, argv
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from time import time  ## for measuring execution time
import ConfigParser  ## for configuration files


# global variables
PROG_VERSION_NUMBER = u"0.1"
PROG_VERSION_DATE = u"2015-01-10"
INVOCATION_TIME = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")

EPILOG = u"\n\
  :copyright:  (c) 2015 and following by Karl Voit <tools@Karl-Voit.at>\n\
  :license:    GPL v3 or any later version\n\
  :URL:        https://github.com/novoid/getdigicamdata.py\n\
  :bugreports: via github (preferred) or <tools@Karl-Voit.at>\n\
  :version:    " + PROG_VERSION_NUMBER + " from " + PROG_VERSION_DATE + "\n"


def error_exit(errorcode):
    """
    Exits with return value of errorcode and prints to stderr.

    @param errorcode: integer that will be reported as return value.
    """

    logger = logging.getLogger('lazyblorg.Utils.error_exit')
    logger.debug("exiting with error code %s" % str(errorcode))

    stdout.flush()
    exit(errorcode)

    
def initialize_logging(identifier, verbose, quiet):
    """Log handling and configuration"""

    logger = logging.getLogger(identifier)

    # create console handler and set level to debug
    ch = logging.StreamHandler()

    FORMAT = None
    if verbose:
        FORMAT = "%(levelname)-8s %(asctime)-15s %(message)s"
        ch.setLevel(logging.DEBUG)
        logger.setLevel(logging.DEBUG)
    elif quiet:
        FORMAT = "%(levelname)-8s %(message)s"
        ch.setLevel(logging.ERROR)
        logger.setLevel(logging.ERROR)
    else:
        FORMAT = "%(levelname)-8s %(message)s"
        ch.setLevel(logging.INFO)
        logger.setLevel(logging.INFO)

    # create formatter
    formatter = logging.Formatter(FORMAT)

    # add formatter to ch
    ch.setFormatter(formatter)

    # add ch to logger
    logger.addHandler(ch)

    ## omit double output (default handler and my own handler):
    logger.propagate = False

    ## # "application" code
    ## logger.debug("debug message")
    ## logger.info("info message")
    ## logger.warn("warn message")
    ## logger.error("error message")
    ## logger.critical("critical message")

    logger.debug("logging initialized")

    return logger



# cmdline parsing
USAGE = "\n\
         %prog [options] FIXXME ...\n\
\n\
FIXXME\n\
\n\
Run %prog --help for usage hints"




def handle_logging():
    """Log handling and configuration"""

    if options.verbose:
        FORMAT = "%(levelname)-8s %(asctime)-15s %(message)s"
        logging.basicConfig(level=logging.DEBUG, format=FORMAT)
    elif options.quiet:
        FORMAT = "%(levelname)-8s %(message)s"
        logging.basicConfig(level=logging.CRITICAL, format=FORMAT)
    else:
        FORMAT = "%(message)s"
        logging.basicConfig(level=logging.INFO, format=FORMAT)


def get_timestamp_string(filename):
    """read out ctime or mtime of file and return timestamp"""

    return time.strftime(FORMATSTRING, time.localtime( os.path.getctime(filename) ) )



## http://sylvana.net/jpegcrop/exif_orientation.html
## Value  0th Row    0th Column
## 1      top        left side  -> normal orientation
## 2      top        right side
## 3      bottom     right side
## 4      bottom     left side
## 5      left side  top
## 6      right side top        -> left side of JPEG is top side
## 7      right side bottom
## 8      left side  bottom     -> right side of JEPG is top side
def get_jpeg_orientation(image):
    if hasattr(image, '_getexif'):
        logging.debug("current image is an JPEG image")
        exiftags = image._getexif()
        ## fetch orientation tag, default = 1 (no rotation)
        orientation = exiftags.get (0x0112,1)
        #logging.debug("orientation is: %s", orientation)
        ## indication of a portrait mode - swap width and height
        if orientation == 1:
            logging.debug ('EXIF orientation tag %s says: photo shot in normal (Landscape) mode', orientation)
        elif orientation == 6:
            logging.debug ('EXIF orientation tag %s says: photo shot in portrait mode with left side of JPEG is top', orientation)
        elif orientation == 8:
            logging.debug ('EXIF orientation tag %s says: photo shot in portrait mode with right side of JPEG is top', orientation)
        else:
            logging.error ('EXIF orientation not recognised!')
        return orientation
    else:
        logging.error("current file is not an JPEG file with EXIF data")


def rotate_and_save_picture(filename, image, degrees):
    temp_filename = TEMP_FILENAME + filename
    new_image = image.rotate(-90, expand=True)
    new_image.save(temp_filename)
    os.remove(filename)
    os.rename(temp_filename, filename)


def rotate_picture_according_exif(filename):
    logging.debug("rotate_picture_according_exif called with file %s", filename)

    image = Image.open(filename)

    orientation = get_jpeg_orientation(image)

    if orientation == 1:
        logging.debug("no rotation required")
    elif orientation == 6:
        logging.debug("will rotate 90 degrees counter clockwise")
        rotate_and_save_picture(filename, image, -90)
    elif orientation == 8:
        logging.debug("will rotate 90 degrees clockwise")
        rotate_and_save_picture(filename, image, 90)
    else:
        logging.warn("Found unknown/unhandled orientation %s", orientation) 



def check_sourcedir():
    logging.debug("FIXXME: not implemented yet")

def check_tempdir():
    logging.debug("FIXXME: not implemented yet")

def check_destdir():
    logging.debug("FIXXME: not implemented yet")


def main():
    """Main function [make pylint happy :)]"""

    
    mydescription = u"FIXXME. Please refer to \n" + \
        "https://github.com/novoid/fetchphotos for more information."

    parser = ArgumentParser(prog=argv[0],
                                     formatter_class=RawDescriptionHelpFormatter,  ## keep line breaks in EPILOG and such
                                     epilog=EPILOG,
                                     description=mydescription)

    parser.add_argument("-p", "--postprocess-only", dest="postprocessonly",
                        action="store_true",
                        help="Just rotate, lowercase, and add timestamp in current directory")
    
    parser.add_argument("-q", "--quiet", dest="quiet", action="store_true",
                        help="Enable quiet mode: only warnings and errors will be reported.")
    
    parser.add_argument("-v", "--verbose", dest="verbose", action="store_true",
                        help="Enable verbose mode which is quite chatty - be warned.")
    
    parser.add_argument("-s", "--dryrun", dest="dryrun", action="store_true",
                        help="Enable dryrun mode: just simulate what would happen, do not modify files or directories")
    
    parser.add_argument("--version", dest="version", action="store_true",
                        help="Display version and exit.")
    
    options = parser.parse_args()

    logging = initialize_logging("lazyblorg", options.verbose, options.quiet)


    
    if options.version:
        print os.path.basename(sys.argv[0]) + " " + PROG_VERSION
        sys.exit(0)

    if len(args) < 1:
        parser.error("invalid usage")

    if ( options.verbose and options.quiet ):
        parser.error("please use either verbose (--verbose) or quiet (-q) option")

    ## FIXXME: implement configuration entry (no cmd line option!)
    no_lowercase = False

    # log handling
    handle_logging()

    filelist = args[0:]
    logging.debug("filelist: [%s]" % filelist)

    check_sourcedir()
    check_tempdir()
    check_destdir()

    ## FIXXME: notify user of download time

    for filename in filelist:
        if os.path.isfile(filename):
            logging.debug("----> is file: %s" % filename)

            new_filename = get_timestamp_string(filename) + "_" + filename

            if not no_lowercase:
                new_filename = new_filename.lower()

            os.rename( filename, new_filename )
            logging.info("%s  -->  %s", filename, new_filename )

            rotate_picture_according_exif(new_filename)




if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logging.info("Received KeyboardInterrupt")

## END OF FILE #################################################################
# vim:foldmethod=indent expandtab ai ft=python tw=120 fileencoding=utf-8 shiftwidth=4
