#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Latest change: Fri Mar 27 00:27:30 CET 2009
"""
fetchphotos
~~~~~~~~~~~

This script gets photos and movies from digicams,
rotates photos according to EXIF data,
adds timestamps,
lowercases filenames, and
tries to notify user on success

:copyright: (c) 2009 by Karl Voit <tools@Karl-Voit.at>
:license: GPL v2 or any later version
:bugreports: <tools@Karl-Voit.at>

"""

import re, os, time, logging, sys
from optparse import OptionParser
from PIL import Image
from PIL.ExifTags import TAGS


# global variables
PROG_VERSION = "0.0.1"
FORMATSTRING = "%Y-%m-%d_%H:%M:%S"
TEMP_FILENAME = "fetchfotos_temp_filename"

# cmdline parsing
USAGE = "\n\
         %prog [options] FIXXME ...\n\
\n\
FIXXME\n\
\n\
Run %prog --help for usage hints"

# pylint: disable-msg=C0103
parser = OptionParser(usage=USAGE)
parser.add_option("-p", "--postprocess-only", dest="postprocessonly",
                  action="store_true",
                  help="just rotate, lowercase, and add timestamp in current directory")
parser.add_option("-q", "--quiet", dest="quiet", action="store_true",
                  help="do not output anything but just errors on console")
parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
                  help="enable verbose mode")
parser.add_option("-s", "--dryrun", dest="dryrun", action="store_true",
        help="enable dryrun mode: just simulate what would happen, do not modify files or directories")
parser.add_option("--version", dest="version", action="store_true",
                  help="display version and exit")
(options, args) = parser.parse_args()


def handle_logging():
    """Log handling and configuration"""

    if options.verbose:
        FORMAT = "%(levelname)-8s %(asctime)-15s %(message)s"
        logging.basicConfig(level=logging.DEBUG, format=FORMAT)
    elif options.quiet:
        FORMAT = "%(levelname)-8s %(message)s"
        logging.basicConfig(level=logging.CRITICAL, format=FORMAT)
    else:
        FORMAT = "%(message)s"
        logging.basicConfig(level=logging.INFO, format=FORMAT)


def get_timestamp_string(filename):
    """read out ctime or mtime of file and return timestamp"""

    return time.strftime(FORMATSTRING, time.localtime( os.path.getctime(filename) ) )



## http://sylvana.net/jpegcrop/exif_orientation.html
## Value  0th Row    0th Column
## 1      top        left side  -> normal orientation
## 2      top        right side
## 3      bottom     right side
## 4      bottom     left side
## 5      left side  top
## 6      right side top        -> left side of JPEG is top side
## 7      right side bottom
## 8      left side  bottom     -> right side of JEPG is top side
def get_jpeg_orientation(image):
    if hasattr(image, '_getexif'):
        logging.debug("current image is an JPEG image")
        exiftags = image._getexif()
        ## fetch orientation tag, default = 1 (no rotation)
        orientation = exiftags.get (0x0112,1)
        #logging.debug("orientation is: %s", orientation)
        ## indication of a portrait mode - swap width and height
        if orientation == 1:
            logging.debug ('EXIF orientation tag %s says: photo shot in normal (Landscape) mode', orientation)
        elif orientation == 6:
            logging.debug ('EXIF orientation tag %s says: photo shot in portrait mode with left side of JPEG is top', orientation)
        elif orientation == 8:
            logging.debug ('EXIF orientation tag %s says: photo shot in portrait mode with right side of JPEG is top', orientation)
        else:
            logging.error ('EXIF orientation not recognised!')
        return orientation
    else:
        logging.error("current file is not an JPEG file with EXIF data")


def rotate_and_save_picture(filename, image, degrees):
    temp_filename = TEMP_FILENAME + filename
    new_image = image.rotate(-90, expand=True)
    new_image.save(temp_filename)
    os.remove(filename)
    os.rename(temp_filename, filename)


def rotate_picture_according_exif(filename):
    logging.debug("rotate_picture_according_exif called with file %s", filename)

    image = Image.open(filename)

    orientation = get_jpeg_orientation(image)

    if orientation == 1:
        logging.debug("no rotation required")
    elif orientation == 6:
        logging.debug("will rotate 90 degrees counter clockwise")
        rotate_and_save_picture(filename, image, -90)
    elif orientation == 8:
        logging.debug("will rotate 90 degrees clockwise")
        rotate_and_save_picture(filename, image, 90)
    else:
        logging.warn("Found unknown/unhandled orientation %s", orientation) 



def check_sourcedir():
    logging.debug("FIXXME: not implemented yet")

def check_tempdir():
    logging.debug("FIXXME: not implemented yet")

def check_destdir():
    logging.debug("FIXXME: not implemented yet")


def main():
    """Main function [make pylint happy :)]"""

    if options.version:
        print os.path.basename(sys.argv[0]) + " " + PROG_VERSION
        sys.exit(0)

    if len(args) < 1:
        parser.error("invalid usage")

    if ( options.verbose and options.quiet ):
        parser.error("please use either verbose (--verbose) or quiet (-q) option")

    ## FIXXME: implement configuration entry (no cmd line option!)
    no_lowercase = False

    # log handling
    handle_logging()

    filelist = args[0:]
    logging.debug("filelist: [%s]" % filelist)

    check_sourcedir()
    check_tempdir()
    check_destdir()

    ## FIXXME: notify user of download time

    for filename in filelist:
        if os.path.isfile(filename):
            logging.debug("----> is file: %s" % filename)

            new_filename = get_timestamp_string(filename) + "_" + filename

            if not no_lowercase:
                new_filename = new_filename.lower()

            os.rename( filename, new_filename )
            logging.info("%s  -->  %s", filename, new_filename )

            rotate_picture_according_exif(new_filename)




if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logging.info("Received KeyboardInterrupt")

## END OF FILE #################################################################
# vim:foldmethod=indent expandtab ai ft=python tw=120 fileencoding=utf-8 shiftwidth=4
